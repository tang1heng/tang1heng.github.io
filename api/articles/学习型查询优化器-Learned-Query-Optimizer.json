{"title":"学习型查询优化器 | Learned Query Optimizer","uid":"703ba5165cdd77e4c0044ba63885ca1f","slug":"学习型查询优化器-Learned-Query-Optimizer","date":"2022-10-29T09:47:04.000Z","updated":"2022-10-29T09:47:50.232Z","comments":true,"path":"api/articles/学习型查询优化器-Learned-Query-Optimizer.json","keywords":null,"cover":[],"content":"<h1 id=\"Learned-Query-Optimizer-学习型查询优化器\"><a href=\"#Learned-Query-Optimizer-学习型查询优化器\" class=\"headerlink\" title=\"Learned Query Optimizer | 学习型查询优化器\"></a>Learned Query Optimizer | 学习型查询优化器</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Learned Query Optimizer: At the Forefront of AI-Driven Databases(EDBT tutorial)</p></blockquote>\n<p><a href=\"https://www.youtube.com/watch?v=LDuLEXa3drM&ab_channel=EDBTAssociation\">视频</a></p>\n<p>论文：<a href=\"https://openproceedings.org/2022/conf/edbt/tutorial-1.pdf\">https://openproceedings.org/2022/conf/edbt/tutorial-1.pdf</a></p>\n<h2 id=\"一：数据库查询优化器（前置知识）\"><a href=\"#一：数据库查询优化器（前置知识）\" class=\"headerlink\" title=\"一：数据库查询优化器（前置知识）\"></a>一：数据库查询优化器（前置知识）</h2><p>查询优化器：对于输入查询生成最好的物理计划。</p>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027105548.png\" alt=\"查询优化器架构-火山框架\"></p>\n<ul>\n<li><p>输入：查询$Q$和数据$D$。</p>\n</li>\n<li><p>输出：计划$P$。</p>\n</li>\n<li><p>困难：在于不同的连接顺序、连接方法、扫描方式等。</p>\n</li>\n<li><p>Planner架构：火山Volcano框架。</p>\n<ul>\n<li>连接顺序选择：枚举所有可能的候选计划。</li>\n<li>基数估计：估计每条子查询的元祖数量。</li>\n<li>代价模型：估计每条子查询的运行时代价。</li>\n</ul>\n</li>\n<li><p>缺点：经验驱动，不够好。</p>\n</li>\n</ul>\n<h2 id=\"二：学习型查询优化器内部组件\"><a href=\"#二：学习型查询优化器内部组件\" class=\"headerlink\" title=\"二：学习型查询优化器内部组件\"></a>二：学习型查询优化器内部组件</h2><h3 id=\"2-1-学习型基数估计\"><a href=\"#2-1-学习型基数估计\" class=\"headerlink\" title=\"2.1 学习型基数估计\"></a>2.1 学习型基数估计</h3><h4 id=\"2-1-1-问题定义和传统方法\"><a href=\"#2-1-1-问题定义和传统方法\" class=\"headerlink\" title=\"2.1.1 问题定义和传统方法\"></a>2.1.1 问题定义和传统方法</h4><p>基数估计问题：在不实际执行查询下估计查询$Q$产生的结果大小$C(Q)$。</p>\n<p>基数估计是代价估计和连接顺序选择问题的基础。</p>\n<p>基数估计的相关性能指标：</p>\n<ul>\n<li><strong>准确度</strong>决定查询计划的质量。</li>\n<li><strong>推理速度（延迟）</strong>决定整体查询运行时间。</li>\n<li>模型大小、训练和更新的时间也很重要。</li>\n</ul>\n<p>传统基数估计方法：</p>\n<ul>\n<li>直方图：基于属性间独立性假设 $Pr(A)\\approx \\prod_i Pr(A_i)$<ul>\n<li>特点：推理速度快、存储成本低、估计误差大</li>\n<li>变种：多维直方图、查询驱动的直方图</li>\n</ul>\n</li>\n<li>抽样：在一个更小的数据抽样集里执行查询<ul>\n<li>特点：在估计准确度和推理速度之间权衡</li>\n<li>变种：核密度估计</li>\n</ul>\n</li>\n<li>连接估计：基于连接均匀性假设<ul>\n<li>估计连接查询 $Q&#x3D;T\\Join R$ 为：$C(Q)&#x3D;Pr_T(Q_T) * Pr_R(Q_R) * |T\\Join R|$</li>\n<li>基于连接的抽样</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-2-学习型查询驱动方法\"><a href=\"#2-1-2-学习型查询驱动方法\" class=\"headerlink\" title=\"2.1.2 学习型查询驱动方法\"></a>2.1.2 学习型查询驱动方法</h4><p>学习型查询驱动方法：通过分析查询负载，学习一个回归模型用来映射从查询$Q$到基数$C(Q)$。</p>\n<ul>\n<li>查询特征工程十分重要。</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027110102.png\" alt=\"查询特征\"></li>\n<li>模型：XGboost、神经网络、树型LSTM、深度集成学习…<ul>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027112051.png\" alt=\"MSCN\"></li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027112135.png\" alt=\"E2E-Card&amp;Cost\"></li>\n</ul>\n</li>\n<li>优点：推理速度快、多用途（连接范式、过滤类型…）</li>\n<li>缺点：估计准确度严重依赖于训练查询负载<ul>\n<li>要求大量用于训练的查询（无法用于新数据库上）</li>\n<li>如果数据或查询工作负载改变，性能会严重下降</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-3-学习型数据驱动方法\"><a href=\"#2-1-3-学习型数据驱动方法\" class=\"headerlink\" title=\"2.1.3 学习型数据驱动方法\"></a>2.1.3 学习型数据驱动方法</h4><p>学习型数据驱动方法：通过分析数据，然后学习表$T$属性$A$上的概率分布函数$Pr_T(A)$。</p>\n<ul>\n<li>$C(Q)&#x3D;Pr_T(A)*|T|$</li>\n<li>构建统计模型来捕获数据分布$Pr_T(A)$</li>\n</ul>\n<p>常见方法：</p>\n<ul>\n<li><strong>深度自回归模型（Neurocard）</strong>：分解联合数据分布为条件分布。<ul>\n<li>$Pr_T(A)&#x3D;Pr_T(A_1)*Pr_T(A_2|A_1)<em>Pr_T(A_3|A_2,A_1)</em>…*Pr_T(A_n|A_{n-1},…,A_1)$</li>\n<li>估计准确度高、模型规模大、推理速度慢。</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027111709.png\" alt=\"Naru\"></li>\n</ul>\n</li>\n<li>概率图模型：<ul>\n<li><strong>贝叶斯网络（BayesCard）</strong>：基于条件独立假设。<ul>\n<li>$Pr(A)&#x3D;\\prod_{i}Pr(A_i|A_{pa(i)})$</li>\n<li>估计准确度高、模型规模小、推理速度快、训练速度慢。</li>\n</ul>\n</li>\n<li><strong>和积网络（DeepDB）</strong>：基于局部独立假设，在属性之间按行分裂来寻找局部独立性。<ul>\n<li>估计准确度、推理速度、模型大小都对属性相关性敏感。</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027111624.png\" alt=\"DeepDB\"></li>\n</ul>\n</li>\n<li><strong>因式分解和积网络（FLAT</strong>）：结合了BN和SPN，自适应地处理高相关和弱相关的属性。<ul>\n<li>估计准确度高、模型规模小、推理速度慢（对于大量属性）。</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027111804.png\" alt=\"FLAT\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>规范化流模型（FACE）</strong>：<ul>\n<li>估计准确度高、推理速度快、模型规模小（紧实）。</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027111925.png\" alt=\"FACE\"></li>\n</ul>\n</li>\n<li>使用基于扇出（fanout）的方法来处理连接（join）查询：<ul>\n<li>表中的每条元祖在连接结果中可以出现多次。</li>\n<li>可以产生准确的估计。</li>\n</ul>\n</li>\n<li>基于界限的方法<ul>\n<li>代替去直接估计基数，而是提供一个上界（最坏的情况）。</li>\n<li>可以避免非常昂贵的连接顺序和物理算子。</li>\n<li>可以生成有效的查询计划但是具有不可承担的延迟。</li>\n<li>严格来说不算基数估计（无法从细节上解释）。</li>\n</ul>\n</li>\n<li>Benchmark<ul>\n<li>IMDB JOB-light<ul>\n<li>有复杂分布的真实世界数据集</li>\n<li>包含6张表，星型连接（join）模式</li>\n</ul>\n</li>\n<li>STATS-CEB</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-1-4-学习型混合方法\"><a href=\"#2-1-4-学习型混合方法\" class=\"headerlink\" title=\"2.1.4 学习型混合方法\"></a>2.1.4 学习型混合方法</h4><ul>\n<li>Learning to be a Statistician: Learned Estimator for Number of Distinct Values</li>\n<li>Flowloss：Flow-Loss: Learning Cardinality Estimates That Matter</li>\n<li>GLUE：</li>\n</ul>\n<h4 id=\"2-1-5-实验对比分析\"><a href=\"#2-1-5-实验对比分析\" class=\"headerlink\" title=\"2.1.5 实验对比分析\"></a>2.1.5 实验对比分析</h4><p>实验结果：</p>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027112237.png\" alt=\"Benchmark\"></p>\n<p>总结：</p>\n<ul>\n<li>传统方法是最通用的、轻量级、很快训练和更新、低延迟、很容易部署在数据库系统上。</li>\n<li>学习型数据驱动方法在估计准确度性能上SOTA，但是不够通用，有的模型过大并且推理速度过慢。</li>\n<li>学习型查询驱动方法在静态数据库实例上表现很好，但是无法用于新数据库，或者数据库在频繁更新或工作负载偏移的场景。</li>\n</ul>\n<h3 id=\"2-2-学习型代价估计\"><a href=\"#2-2-学习型代价估计\" class=\"headerlink\" title=\"2.2 学习型代价估计\"></a>2.2 学习型代价估计</h3><ul>\n<li>任务目标：给定一条SQL查询Q的物理执行计划P，基于查询Q的基数以及P的算子，去估计查询执行时间&#x2F;资源消耗。</li>\n<li>相关性：代价估计依赖于基数。</li>\n<li>估计困难度：比基数估计更加苦难，因为需要考虑不同因素（比如顺序扫描成本、CPU使用率等等）。</li>\n<li>方法分类：<ul>\n<li>单条查询的代价估计：<ul>\n<li>特点：end2end，基于树型的计划编码。</li>\n<li>关键思想：使用之前的计划来训练一个树型的神经网络，用来直接预测代价。</li>\n</ul>\n</li>\n<li>多条查询（并发下）的代价估计：<ul>\n<li>特点：一条计划的性能可能由于计划之间的相关性而不同。</li>\n<li>关键思想：使用一个图来表征计划之间的相关性，然后使用一个神经网络来预测代价。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-2-1-经验驱动方法（基于规则）\"><a href=\"#2-2-1-经验驱动方法（基于规则）\" class=\"headerlink\" title=\"2.2.1 经验驱动方法（基于规则）\"></a>2.2.1 经验驱动方法（基于规则）</h4><h4 id=\"2-2-2-单条查询的代价估计\"><a href=\"#2-2-2-单条查询的代价估计\" class=\"headerlink\" title=\"2.2.2 单条查询的代价估计\"></a>2.2.2 单条查询的代价估计</h4><p>挑战：</p>\n<ul>\n<li>构建一个端到端的模型用于代价估计，防止基数估计误差造成的累计误差。</li>\n<li>学习模型应该捕获查询计划中的树型结构信息。</li>\n<li>难以对谓词进行编码。</li>\n</ul>\n<p>Tree-LSTM：</p>\n<ul>\n<li>表征层：学习每条子查询的嵌入。</li>\n<li>估计层：同时输出基数和代价。</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027200956.png\" alt=\"E2E-Cost\"></p>\n<h4 id=\"2-2-3-并发查询的代价估计\"><a href=\"#2-2-3-并发查询的代价估计\" class=\"headerlink\" title=\"2.2.3 并发查询的代价估计\"></a>2.2.3 并发查询的代价估计</h4><p>现有方法专注于预测单个查询的性能，但不能有效地预测并发查询的性能，因为<em>很难捕捉不同查询之间的相关性</em>，例如锁冲突和缓冲区共享。</p>\n<ul>\n<li>查询之间有复杂的联系</li>\n<li>数据配置的约束</li>\n</ul>\n<p>QPP：</p>\n<ul>\n<li>顶点建模：获取查询计划；从计划中抽取算子作为顶点特征。</li>\n<li>边建模：计算四种类型的边之间的关系<ul>\n<li>Parent-Child</li>\n<li>Data Sharing</li>\n<li>Data Conflict</li>\n<li>Resource</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027201734.png\"></p>\n<h3 id=\"2-3-学习型连接顺序搜索\"><a href=\"#2-3-学习型连接顺序搜索\" class=\"headerlink\" title=\"2.3 学习型连接顺序搜索\"></a>2.3 学习型连接顺序搜索</h3><p>连接顺序枚举：给定一条SQL查询，一个连接join排序被二叉树捕获，叶子节点表示一个基表关系。目标是选择最“便宜”的排序（根据代价模型）。</p>\n<h4 id=\"2-3-1-问题定义和现存方法\"><a href=\"#2-3-1-问题定义和现存方法\" class=\"headerlink\" title=\"2.3.1 问题定义和现存方法\"></a>2.3.1 问题定义和现存方法</h4><ul>\n<li>离线：<ul>\n<li>特征：基于工作负载，使用基于强化学习的方法。</li>\n<li>关键思想：使用现存的负载来训练一个学习型优化器，用来预测未来的负载的计划。</li>\n</ul>\n</li>\n<li>在线：<ul>\n<li>特征：不提供工作负载，但是依赖于定制数据库。</li>\n<li>关键思想：查询计划可以在执行中改变。一旦发现当前计划是糟糕的，就可以选择切换到另外一个计划。这种方法在数据库实际执行查询时才开始学习。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-2-离线学习方法\"><a href=\"#2-3-2-离线学习方法\" class=\"headerlink\" title=\"2.3.2 离线学习方法\"></a>2.3.2 离线学习方法</h4><p>背景：</p>\n<ul>\n<li>连接顺序的搜索空间巨大。</li>\n<li>传统优化器无法从之前的例子中学习。</li>\n</ul>\n<p>挑战：</p>\n<ul>\n<li>如何减少连接顺序的搜索空间？</li>\n<li>如何选择最好的连接顺序？</li>\n</ul>\n<p>ReJoin：</p>\n<ul>\n<li>强化学习模型<ul>\n<li>agent：optimizer</li>\n<li>action：join</li>\n<li>env：cost mode，database</li>\n<li>reward：cost，latency</li>\n<li>state：join order</li>\n</ul>\n</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027215157.png\" alt=\"ReJOIN\"></li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027220457.png\" alt=\"查询表征\"></li>\n</ul>\n<p>RTOS：</p>\n<ul>\n<li>将TreeLSTM作为Q network</li>\n<li>两步骤训练：<ul>\n<li>代价预训练</li>\n<li>延迟微调</li>\n</ul>\n</li>\n<li>动态神经网络<ul>\n<li>通过DFS来为每条计划构建神经网络。</li>\n</ul>\n</li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027220702.png\" alt=\"RTOS\"></li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027221352.png\"></li>\n</ul>\n<h4 id=\"2-3-3-在线学习方法\"><a href=\"#2-3-3-在线学习方法\" class=\"headerlink\" title=\"2.3.3 在线学习方法\"></a>2.3.3 在线学习方法</h4><p>背景：</p>\n<ul>\n<li>真实数据库负载差异大。</li>\n<li>之前基于学习的优化器需要提供训练查询，很难针对不同负载给出好的计划。</li>\n</ul>\n<p>挑战：</p>\n<ul>\n<li>如何设计一个新的工作机制来允许优化器学习并切换到不同的连接顺序（在线）。</li>\n<li>如何评估并选择不同的连接顺序（在线）。</li>\n</ul>\n<h4 id=\"2-3-4-对比分析\"><a href=\"#2-3-4-对比分析\" class=\"headerlink\" title=\"2.3.4 对比分析\"></a>2.3.4 对比分析</h4><p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221027222500.png\" alt=\"对比\"></p>\n<h3 id=\"2-4-总结\"><a href=\"#2-4-总结\" class=\"headerlink\" title=\"2.4 总结\"></a>2.4 总结</h3><ul>\n<li><p>基数估计 CardEst</p>\n</li>\n<li><p>代价估计 CostEst</p>\n</li>\n<li><p>连接选择 JoinSel</p>\n</li>\n<li><p>它们可以一起工作来生成最佳的查询计划。</p>\n<ul>\n<li>比如，JoinSel 可以基于 CostEst 来选择一个好的顺序。</li>\n</ul>\n</li>\n<li><p>它们都可以通过机器学习技术来优化。</p>\n<ul>\n<li>CostEst 利用神经网络来编码查询并预测代价，CardEst 的方法也可以使用。</li>\n<li>JoinSel 依赖于基于强化学习的方法，因为连接顺序选择问题可以看成是一个做决定的过程，并且数据库可以提供反馈作为回报。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三：学习型查询优化器整体模块\"><a href=\"#三：学习型查询优化器整体模块\" class=\"headerlink\" title=\"三：学习型查询优化器整体模块\"></a>三：学习型查询优化器整体模块</h2><h3 id=\"3-1-端到端学习型QO：Neo\"><a href=\"#3-1-端到端学习型QO：Neo\" class=\"headerlink\" title=\"3.1 端到端学习型QO：Neo\"></a>3.1 端到端学习型QO：Neo</h3><ul>\n<li>从输入查询到可执行的计划。</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028143343.png\" alt=\"Neo\"></p>\n<ul>\n<li>SQL查询级别的编码：<ul>\n<li>连接信息</li>\n<li>谓词信息</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028144328.png\" alt=\"Query Encoding\"></p>\n<ul>\n<li>查询执行计划的编码：</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028144512.png\" alt=\"Plan Encoding\"></p>\n<ul>\n<li>价值网络：<ul>\n<li>网络架构：树卷积<ul>\n<li>基于归纳偏置：树形结构的查询计划</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028144715.png\" alt=\"Value Network\"></p>\n<ul>\n<li>树卷积操作<ul>\n<li>自动为不同的算子、表学习 filter 的权重</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028150848.png\" alt=\"tree convolution\"></p>\n<ul>\n<li>优点：<ul>\n<li>第一个自动的<strong>端到端</strong>地学习型查询优化器</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>从零学习整个查询优化器的所有东西：长的训练时间和重的冷启动问题</li>\n<li>对每个数据库都需要特定的特征化：很难泛化到更新场景。</li>\n<li>代替而不是修改：无法重用现存的DBMS代码。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-学习引导QO：Bao\"><a href=\"#3-2-学习引导QO：Bao\" class=\"headerlink\" title=\"3.2 学习引导QO：Bao\"></a>3.2 学习引导QO：Bao</h3><p>背景：</p>\n<ul>\n<li>现存查询优化器有不同的hint set（提示集）：可以disable或enable特定类型的算子，比如禁止loop join等。</li>\n<li>对于每条查询，调整到一个好的hint set可以有助于生成一个好的计划。</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028152038.png\" alt=\"JOB Query\"></p>\n<ul>\n<li>学习在现存查询优化器上找到正确的hint set。</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028152215.png\" alt=\"Bao\"></p>\n<ul>\n<li>Bao的预测模型架构<ul>\n<li>和Neo一样基于树卷积</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028153146.png\" alt=\"Bao的预测网络\"></p>\n<p>评估结果：</p>\n<ul>\n<li>在长时间训练后Neo可以胜过Bao，因为Neo比Bao在计划选择上更自由（有更大的选择空间）。</li>\n<li>Bao更快更容易适应于动态负载环境。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>引导而不是替代：重用现存查询优化器，更容易部署。</li>\n<li>容易适应数据、查询、系统更新：更好的泛化能力。</li>\n<li>更小的训练时间（相比于Neo）</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>计划选择空间受限：性能有时会损失。</li>\n<li>冷启动问题和回归问题仍然存在。</li>\n</ul>\n<p>学习型QO对比：</p>\n<ul>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028160520.png\" alt=\"Learned-QO对比\"></li>\n<li><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221028160723.png\" alt=\"训练时间和性能对比\"></li>\n</ul>\n<h3 id=\"3-3-统一、可迁移的模型：MTMLF\"><a href=\"#3-3-统一、可迁移的模型：MTMLF\" class=\"headerlink\" title=\"3.3 统一、可迁移的模型：MTMLF\"></a>3.3 统一、可迁移的模型：MTMLF</h3><p>基本思想：学习到的知识是可分解的。</p>\n<ul>\n<li>任务特定的知识：用来解决特定任务，比如连接顺序（排序）选择的规则。<ul>\n<li>用一个小模型去适应每个任务。</li>\n</ul>\n</li>\n<li>任务共享的知识：数据和查询表征（可以在所有任务中使用）。<ul>\n<li>学习查询语句的统一表征。</li>\n</ul>\n</li>\n<li>数据特定的知识：比如数据和查询负载分布。<ul>\n<li>适应每个数据库。</li>\n</ul>\n</li>\n<li>数据无关的元知识：跨数据库的常见规则，比如专家经验、多表连接规则。<ul>\n<li>在不同数据库间总结元数据。</li>\n</ul>\n</li>\n</ul>\n<p>微调预先训练号好的模型来适应用户数据：</p>\n<p>架构：</p>\n<ul>\n<li>更有效的训练，而不是对冗余知识的学习。</li>\n<li>更高效的任务建模，在有先验知识的指导下，比如从代价估计到基数估计。</li>\n<li>可转移能力，避免冷启动回归问题。</li>\n</ul>\n<p>工作流：</p>\n<ul>\n<li>预训练大模型提供基础工具。</li>\n<li>更深度的优化：能看到更多的数据。</li>\n<li>容易进化和管理。</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221029173154.png\" alt=\"MTMLF-Q\"></p>\n<p>实验评估结果：</p>\n<ul>\n<li>one mode for all 架构更准确<ul>\n<li>多任务学习 &gt; 单独学习</li>\n</ul>\n</li>\n<li>one mode for all 架构更有效<ul>\n<li>预训练+微调 范式可以迁移到新数据库上</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221029172956.png\"></p>\n<p><img src=\"https://images-1304805469.cos.ap-chengdu.myqcloud.com/img/20221029173317.png\"></p>\n<h3 id=\"3-4-比较和分析\"><a href=\"#3-4-比较和分析\" class=\"headerlink\" title=\"3.4 比较和分析\"></a>3.4 比较和分析</h3><ul>\n<li>Neo：从零学习整个查询优化器，端到端。<ul>\n<li>长的训练时间、低的泛化能力、严重的冷启动问题。</li>\n</ul>\n</li>\n<li>Bao：学习引导现存的查询优化器，通过调整提示集。<ul>\n<li>容易部署和更好的泛化能力。</li>\n<li>性能损失，仍然存在冷启动问题。</li>\n</ul>\n</li>\n<li>MTMLF：预训练+微调<ul>\n<li>一个可能的方向，对于学习型查询优化器来说。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四：应用和部署\"><a href=\"#四：应用和部署\" class=\"headerlink\" title=\"四：应用和部署\"></a>四：应用和部署</h2><h3 id=\"4-1-学习型QO的应用案例研究\"><a href=\"#4-1-学习型QO的应用案例研究\" class=\"headerlink\" title=\"4.1 学习型QO的应用案例研究\"></a>4.1 学习型QO的应用案例研究</h3><h4 id=\"4-1-1-将学习型代价模型装配到微软SCOPE查询优化器\"><a href=\"#4-1-1-将学习型代价模型装配到微软SCOPE查询优化器\" class=\"headerlink\" title=\"4.1.1 将学习型代价模型装配到微软SCOPE查询优化器\"></a>4.1.1 将学习型代价模型装配到微软SCOPE查询优化器</h4><h4 id=\"4-1-2-学习引导微软SCOPE查询优化器\"><a href=\"#4-1-2-学习引导微软SCOPE查询优化器\" class=\"headerlink\" title=\"4.1.2 学习引导微软SCOPE查询优化器\"></a>4.1.2 学习引导微软SCOPE查询优化器</h4><h3 id=\"4-2-真实部署面临的挑战\"><a href=\"#4-2-真实部署面临的挑战\" class=\"headerlink\" title=\"4.2 真实部署面临的挑战\"></a>4.2 真实部署面临的挑战</h3><h3 id=\"4-3-Baihe\"><a href=\"#4-3-Baihe\" class=\"headerlink\" title=\"4.3 Baihe\"></a>4.3 Baihe</h3><h2 id=\"五：总结和未来工作\"><a href=\"#五：总结和未来工作\" class=\"headerlink\" title=\"五：总结和未来工作\"></a>五：总结和未来工作</h2><h3 id=\"5-1-总结\"><a href=\"#5-1-总结\" class=\"headerlink\" title=\"5.1 总结\"></a>5.1 总结</h3><ul>\n<li>学习查询优化器中的关键组件</li>\n<li>学习整个查询优化器</li>\n</ul>\n<h3 id=\"5-2-未来工作\"><a href=\"#5-2-未来工作\" class=\"headerlink\" title=\"5.2 未来工作\"></a>5.2 未来工作</h3><ul>\n<li>基数估计<ul>\n<li>融合数据驱动和查询驱动方法</li>\n<li>适应性方法：AP和TP场景、不同的数据和查询工作负载</li>\n<li>性能提升：<ul>\n<li>更新速度</li>\n<li>多表查询上的准确度</li>\n<li>意识到不同子查询</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>代价模型和连接选择<ul>\n<li>自动生成足够的训练数据（覆盖范围大）</li>\n<li>鲁棒模型，针对动态负载或不同场景</li>\n<li>给定一个负载和数据集，智能AI算法选择</li>\n</ul>\n</li>\n<li>学习型QO<ul>\n<li>预训练+微调</li>\n<li>新架构用来引导现存QO</li>\n<li>新的训练、更新策略</li>\n</ul>\n</li>\n<li>应用和部署<ul>\n<li>通用的部署工具</li>\n<li>定制化调整</li>\n</ul>\n</li>\n<li>除了QO：延伸到其他AI4DB任务<ul>\n<li>indexing</li>\n<li>advisor</li>\n<li>diagnosis</li>\n</ul>\n</li>\n</ul>\n","text":"Learned Query Optimizer | 学习型查询优化器 Learned Query Optimizer: At the Forefront of AI-Driven Databases(EDBT tutorial) 视频 论文：https://openproceed...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"查询优化","slug":"查询优化","count":1,"path":"api/tags/查询优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Learned-Query-Optimizer-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8\"><span class=\"toc-text\">Learned Query Optimizer | 学习型查询优化器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%88%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%89\"><span class=\"toc-text\">一：数据库查询优化器（前置知识）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%9E%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">二：学习型查询优化器内部组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E5%9F%BA%E6%95%B0%E4%BC%B0%E8%AE%A1\"><span class=\"toc-text\">2.1 学习型基数估计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-1-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1.1 问题定义和传统方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-2-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E6%9F%A5%E8%AF%A2%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1.2 学习型查询驱动方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-3-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1.3 学习型数据驱动方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-4-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1.4 学习型混合方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-5-%E5%AE%9E%E9%AA%8C%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.1.5 实验对比分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E4%BB%A3%E4%BB%B7%E4%BC%B0%E8%AE%A1\"><span class=\"toc-text\">2.2 学习型代价估计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-1-%E7%BB%8F%E9%AA%8C%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%EF%BC%89\"><span class=\"toc-text\">2.2.1 经验驱动方法（基于规则）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-2-%E5%8D%95%E6%9D%A1%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BB%A3%E4%BB%B7%E4%BC%B0%E8%AE%A1\"><span class=\"toc-text\">2.2.2 单条查询的代价估计</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-3-%E5%B9%B6%E5%8F%91%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BB%A3%E4%BB%B7%E4%BC%B0%E8%AE%A1\"><span class=\"toc-text\">2.2.3 并发查询的代价估计</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%AD%A6%E4%B9%A0%E5%9E%8B%E8%BF%9E%E6%8E%A5%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2\"><span class=\"toc-text\">2.3 学习型连接顺序搜索</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-1-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89%E5%92%8C%E7%8E%B0%E5%AD%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3.1 问题定义和现存方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-2-%E7%A6%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3.2 离线学习方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-3-%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.3.3 在线学习方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-4-%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.3.4 对比分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">2.4 总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%9E%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%95%B4%E4%BD%93%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">三：学习型查询优化器整体模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%AD%A6%E4%B9%A0%E5%9E%8BQO%EF%BC%9ANeo\"><span class=\"toc-text\">3.1 端到端学习型QO：Neo</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%AD%A6%E4%B9%A0%E5%BC%95%E5%AF%BCQO%EF%BC%9ABao\"><span class=\"toc-text\">3.2 学习引导QO：Bao</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E7%BB%9F%E4%B8%80%E3%80%81%E5%8F%AF%E8%BF%81%E7%A7%BB%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%9AMTMLF\"><span class=\"toc-text\">3.3 统一、可迁移的模型：MTMLF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E6%AF%94%E8%BE%83%E5%92%8C%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.4 比较和分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%EF%BC%9A%E5%BA%94%E7%94%A8%E5%92%8C%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">四：应用和部署</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E5%AD%A6%E4%B9%A0%E5%9E%8BQO%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6\"><span class=\"toc-text\">4.1 学习型QO的应用案例研究</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-1-%E5%B0%86%E5%AD%A6%E4%B9%A0%E5%9E%8B%E4%BB%A3%E4%BB%B7%E6%A8%A1%E5%9E%8B%E8%A3%85%E9%85%8D%E5%88%B0%E5%BE%AE%E8%BD%AFSCOPE%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8\"><span class=\"toc-text\">4.1.1 将学习型代价模型装配到微软SCOPE查询优化器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-2-%E5%AD%A6%E4%B9%A0%E5%BC%95%E5%AF%BC%E5%BE%AE%E8%BD%AFSCOPE%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8\"><span class=\"toc-text\">4.1.2 学习引导微软SCOPE查询优化器</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E7%9C%9F%E5%AE%9E%E9%83%A8%E7%BD%B2%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98\"><span class=\"toc-text\">4.2 真实部署面临的挑战</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-Baihe\"><span class=\"toc-text\">4.3 Baihe</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%EF%BC%9A%E6%80%BB%E7%BB%93%E5%92%8C%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">五：总结和未来工作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5.1 总结</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">5.2 未来工作</span></a></li></ol></li></ol></li></ol>","author":{"name":"Tomison","slug":"blog-author","avatar":"https://image.doubilm.com/images/2022-07-26/1658841958985.gif","link":"/","description":"一个热爱健身和穿搭的技术人。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{}}